# Pandas {#pandas}

## File I/O
Read a csv file into a DataFrame.
```{python eval=FALSE}
pd.read_csv(filepath)
```

Write a DataFrame to a file.
```{python eval=FALSE}
x.to_csv(path_or_buf='outputDir', sep='\n', header=False, index=False)
```

## Relabeling
Rename a column or group of columns can be done by passing a dictionary of the changes.
```{python eval=FALSE}
    df = df.rename(columns={'a':'b','c':'d'})
```

## Sorting and Arranging
The data in a DataFrame can be sorted in numeric or lexicographic order.
The following code sorts the values within the columns a and b.
```{python eval=FALSE}
df.sort_values(['a','b'], ascending=False)
```

## Editing Data 
Drop columns from a DataFrame.
```{python eval=FALSE}
import numpy as np
df = pd.DataFrame(np.arange(12).reshape(3,4),
                    columns=['A', 'B', 'C', 'D'])
print(df)

df = df.drop(columns=['B', 'C']) # may not work in python 2
df = df.drop(['B', 'C'], axis=1) # this works in python 2
print(df)
```

Changing the datatype of a column of data can be done by just changing column type.
```{python eval=FALSE}
df.Age = df.Age.astype(str)
```

### Replace values 
New data can be set within a DataFrame one subset at a time in a way that will avoid the SettingWithCopyWarning.
```{python}
import pandas as pd
df = pd.DataFrame({'Trait':['Seed_Shape','Seed_Shape','Flower_Color','Flower_Color'],
                    'Phenotype':['Round','Wrinkled','Purple','White']})
df.loc[df.Trait == 'Seed_Shape', 'Affected_Part'] = 'Seed'
df.loc[df.Trait == 'Flower_Color', 'Affected_Part'] = 'Flower'
print(df)
```

There is a more simple alternative to the above method buit it may result in the SettingWithCopyWarning.
```{python eval=FALSE}
df = df.replace('pork','bacon')
```

## Combining Data Structures
The following merges df and df2 using inner to get the intersection on the Sample column, where indexes are ignored if the merging is performed on a column as in the following example.
The other possible merging strategies are:
left: use only keys from left frame, similar to a SQL left outer join; preserve key order.
right: use only keys from right frame, similar to a SQL right outer join; preserve key order.
outer: use union of keys from both frames, similar to a SQL full outer join; sort keys lexicographically.
inner: use intersection of keys from both frames, similar to a SQL inner join; preserve the order of the left keys.
```{python eval=FALSE}
df = pd.merge(df, df2, how='inner', on=['Sample'])
```

Appending to a Dataframe attaches a DataFrame after another one.
```{python eval=FALSE}
df = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB'))
df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB'))
df.append(df2)
```

## Splitting
Remove duplicates
```{python eval=FALSE}
x = x[~x.index.duplicated(keep='first')] # most ideal method

data = pd.DataFrame({'k1':['one','two']*3+['two'],'k2':[1,1,2,3,3,4,4]})
data.duplicated() # identify duplicate data
data[‘k1’].duplicated()
data['k1'].drop_duplicates()
data.drop_duplicates['k1'] # this does the same thing as the previous line
data.drop_duplicates(['k1','k2'], keep='last') # drops unique found in k1 and k2 and keeps the last indexed duplicate
```

## Summarizing
The mean of column values can be calculated where each of the columns is grouped by the data in a specified column.
```{python eval=FALSE}
temp[['Sample','VAF','Var_Count']].groupby('Sample').mean()
```

## Arithmetic and Row-wise Analysis
Sometimes it is helpful to analyze the value in a particular cell in a conditional manner depending on it's value and then set the result of this analysis to a corresponding cell in a new column. Here is an example where the VAF of a variant is conditionally analyzed
```{python eval=FALSE}
def LOH(x):
    if x > 0.75: return 1 - x
    elif x <= 0.75 and x > 0.25: return abs(0.5 - x)
    else: return 0
all_vars['LOH'] = all_vars.VAF.transform(LOH)
max_loh = all_vars.groupby('Sample').LOH.max().reset_index().rename(columns={'LOH':'Max_LOH'})
all_vars = pd.merge(all_vars, max_loh, how='inner', on=['Sample'])
```

